[{"C:\\Users\\chrfe\\Desktop\\Informatik Projekte\\Website\\react\\chess-game\\src\\index.js":"1","C:\\Users\\chrfe\\Desktop\\Informatik Projekte\\Website\\react\\chess-game\\src\\chess.js":"2","C:\\Users\\chrfe\\Desktop\\Informatik Projekte\\Website\\react\\chess-game\\src\\chess_ai.js":"3"},{"size":22031,"mtime":1615886385000,"results":"4","hashOfConfig":"5"},{"size":44296,"mtime":1613939321499,"results":"6","hashOfConfig":"5"},{"size":6759,"mtime":1613293454004,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"1umvizx",{"filePath":"10","messages":"11","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"12","usedDeprecatedRules":"13"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"13"},"C:\\Users\\chrfe\\Desktop\\Informatik Projekte\\Website\\react\\chess-game\\src\\index.js",["17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34"],"C:\\Users\\chrfe\\Desktop\\Informatik Projekte\\Website\\react\\chess-game\\src\\chess.js",["35","36","37","38","39","40","41","42","43","44","45","46"],"import testUtils from \"react-dom/test-utils\";\r\n\r\nlet EMPTY = \"  \";\r\nlet WHITE = 0;\r\nlet BLACK = 1;\r\n\r\nexport default class Board {\r\n    constructor()\r\n    {\r\n        this.board = this.create_board();\r\n        this.historyBoards = [JSON.parse(JSON.stringify(this.board)),JSON.parse(JSON.stringify(this.board)),JSON.parse(JSON.stringify(this.board)),JSON.parse(JSON.stringify(this.board))];\r\n        this.uglyMoveStates = [];\r\n        \r\n        this.current_color = WHITE;\r\n        this.isWhiteCheck = false;\r\n        this.isBlackCheck = false;\r\n        //Überprüft ob und in welche Richtung jeweils weiß und schwarz castlen können\r\n        //Erster Eintrag Weiß, zweiter Schwarz\r\n        //Im Array: Lang rochieren, kurz rochieren\r\n        this.castlePossible = [[true,true],[true,true]];\r\n        //Ob man gerade am Rochieren ist\r\n        this.staleMate = false;\r\n        this.checkMate = false;\r\n        this.moveRepitition = 0;\r\n        this.moveHistoryIndex = -1;\r\n        this.moveHistory = [];\r\n    }\r\n    \r\n    reset()\r\n    {\r\n        this.board = this.create_board();\r\n        this.historyBoards = [JSON.parse(JSON.stringify(this.board)),JSON.parse(JSON.stringify(this.board)),JSON.parse(JSON.stringify(this.board)),JSON.parse(JSON.stringify(this.board))];\r\n        this.uglyMoveStates = [];\r\n        \r\n        this.current_color = WHITE;\r\n        this.isWhiteCheck = false;\r\n        this.isBlackCheck = false;\r\n        //Überprüft ob und in welche Richtung jeweils weiß und schwarz castlen können\r\n        //Erster Eintrag Weiß, zweiter Schwarz\r\n        //Im Array: Lang rochieren, kurz rochieren\r\n        this.castlePossible = [[true,true],[true,true]];\r\n        //Ob man gerade am Rochieren ist\r\n        this.staleMate = false;\r\n        this.checkMate = false;\r\n        this.moveRepitition = 0;\r\n        this.moveHistoryIndex = -1;\r\n        this.moveHistory = [];\r\n    }\r\n    \r\n    getPossibleNodes(depth, state)\r\n    {\r\n        console.log(\"Started with depth: \"+ depth);\r\n        var testBoard = new Board();\r\n        var baseBoard = new Board();\r\n        if(state != null)\r\n        {\r\n            baseBoard.board = JSON.parse(JSON.stringify(state[0]));\r\n            baseBoard.historyBoards = [JSON.parse(JSON.stringify(baseBoard.board)),JSON.parse(JSON.stringify(baseBoard.board)),JSON.parse(JSON.stringify(baseBoard.board)),JSON.parse(JSON.stringify(baseBoard.board))];\r\n            baseBoard.current_color = state[1];\r\n            baseBoard.castlePossible = JSON.parse(JSON.stringify(state[2]));\r\n            baseBoard.calculateChecks();\r\n\r\n            testBoard.board = JSON.parse(JSON.stringify(state[0]));\r\n            testBoard.historyBoards = [JSON.parse(JSON.stringify(testBoard.board)),JSON.parse(JSON.stringify(testBoard.board)),JSON.parse(JSON.stringify(testBoard.board)),JSON.parse(JSON.stringify(testBoard.board))];\r\n            testBoard.current_color = state[1];\r\n            testBoard.castlePossible = JSON.parse(JSON.stringify(state[2]));\r\n            testBoard.calculateChecks();\r\n            if(testBoard.isCheckMate())\r\n            {\r\n                return 0;\r\n            }\r\n            if(testBoard.staleMate)\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n        \r\n        if(depth == 0)\r\n        {\r\n            testBoard.printBoard(testBoard.board);\r\n            console.log(testBoard.ugly_moves());\r\n            return 1;\r\n        }\r\n        \r\n        var nodes = 0;\r\n        var possibleMoves = testBoard.ugly_moves();\r\n        console.log(possibleMoves.length);\r\n        for(var i = 0;i<possibleMoves.length;i++)\r\n        {\r\n            if(!testBoard.equals(baseBoard))\r\n            {\r\n                console.log(depth);\r\n            }\r\n            var possible = testBoard.ugly_move(possibleMoves[i]);\r\n            if(!possible)\r\n            {\r\n                console.log(depth);\r\n            }\r\n            if(depth != 0)\r\n            {\r\n                var possibleNodes = this.getPossibleNodesHelper(depth-1, testBoard);\r\n                if(depth >= 4)\r\n                {\r\n                    var col = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"][possibleMoves[i][1]];\r\n                    console.log(\"Move: \" + col +   (8-possibleMoves[i][0])  + [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"][possibleMoves[i][3]]   + (8-possibleMoves[i][2]) + \"  \" + possibleMoves[i][4]  + \" \" + possibleNodes + \" nodes\");\r\n                }\r\n                nodes += possibleNodes;\r\n            }\r\n            testBoard.undo();\r\n        }\r\n        console.log(\"Depth: \"+ depth + \" \" + nodes + \" nodes\");\r\n        return nodes;\r\n    }\r\n    \r\n    equals(boardObject)\r\n    {\r\n        for(var i =0;i<8;i++)\r\n        {\r\n            for(var j=0; j<8;j++)\r\n            {\r\n                if(this.board[i][j] !== boardObject.board[i][j])\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        for(var k =0;k<4;k++)\r\n        {\r\n            for(var i =0;i<8;i++)\r\n            {\r\n                for(var j=0; j<8;j++)\r\n                {\r\n                    if(this.historyBoards[k][i][j] !== boardObject.historyBoards[k][i][j])\r\n                    {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if(this.castlePossible[0][0] !== boardObject.castlePossible[0][0] || this.castlePossible[0][1] !== boardObject.castlePossible[0][1] ||  this.castlePossible[1][0] !== boardObject.castlePossible[1][0] || this.castlePossible[1][1] !== boardObject.castlePossible[1][1])\r\n        {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    getPossibleNodesHelper(depth, testBoard)\r\n    {\r\n        var nodes = 0;\r\n        var possibleMoves = testBoard.ugly_moves();\r\n        if(depth == 0)\r\n        {\r\n            return 1;\r\n        }\r\n        for(var i = 0;i<possibleMoves.length;i++)\r\n        {\r\n            var possible = testBoard.ugly_move(possibleMoves[i]); \r\n            if(!possible)\r\n            {\r\n                console.log(depth);\r\n            }\r\n            if(depth != 0)\r\n            {\r\n                var possibleNodes = this.getPossibleNodesHelper(depth-1, testBoard);\r\n                // if(depth == 1)\r\n                // {\r\n                //     var col = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"][possibleMoves[i][1]];\r\n                //     console.log(\"Move: \" + col +   (8-possibleMoves[i][0])  + [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"][possibleMoves[i][3]]   + (8-possibleMoves[i][2])   + \" \" + possibleNodes + \" nodes\");\r\n                // }\r\n                nodes += possibleNodes;\r\n            }\r\n            testBoard.undo();\r\n        }\r\n        return nodes;\r\n    }\r\n    \r\n    printBoard(arr)\r\n    {\r\n        for(var i = 0;i < arr.length; i++)\r\n        {\r\n            console.log(arr[i]);\r\n        }\r\n    }\r\n    \r\n    printStatus(move)\r\n    {\r\n        this.printBoard(this.board);\r\n        console.log(\"Move: \" + move);\r\n        console.log(\"Depth: \" + this.uglyMoveStates.length);\r\n        console.log(\"Current Color: \"  + this.current_color)\r\n        console.log(\"White Check: \"  + this.isWhiteCheck)\r\n        console.log(\"Black Check: \"  + this.isBlackCheck)\r\n        console.log(\"Castle Possible: \"  + this.castlePossible);\r\n        console.log(\"Checkmate: \"  + this.checkMate);\r\n        console.log(\"Stalemate: \"  + this.staleMate);\r\n        console.log(\"Move Repition Count: \"  + this.moveRepitition);\r\n        console.log(\"History Index: \"  + this.moveHistoryIndex);\r\n        console.log(this.moveHistory);\r\n    }\r\n    \r\n    arrayColumn = (arr, n) => arr.map(x => x[n]);\r\n    \r\n    create_board()\r\n    {\r\n        var board = [];\r\n        board.push([\"r1\",\"n1\",\"b1\",\"q1\",\"k1\",\"b1\",\"n1\",\"r1\"])\r\n        board.push([\"p1\",\"p1\",\"p1\",\"p1\",\"p1\",\"p1\",\"p1\",\"p1\"])\r\n        for(var i = 0; i<4;i++)\r\n        {\r\n            board.push([EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY])\r\n        }\r\n        board.push([\"p0\",\"p0\",\"p0\",\"p0\",\"p0\",\"p0\",\"p0\",\"p0\"]);\r\n        board.push([\"r0\",\"n0\",\"b0\",\"q0\",\"k0\",\"b0\",\"n0\",\"r0\"])\r\n        return board;\r\n    }\r\n    \r\n    movePiece(startRow, startCol, destinationRow, destinationCol, promotionPiece)\r\n    {\r\n        \r\n        if(this.checkMate === true || this.staleMate === true)\r\n        {\r\n            console.log(\"Checkmate:\" + this.checkMate + \" Stalemate: \" + this.staleMate);\r\n            return [false,false,false,false];\r\n        }\r\n        var [isPossible,isCastling, isEnPassant, isPromotion] = this.isMovePossible(startRow,startCol,destinationRow,destinationCol);\r\n        if(isPossible)\r\n        {\r\n            this.addToMoveHistory(startRow, startCol, destinationRow, destinationCol, promotionPiece, isPossible, isCastling, isEnPassant, isPromotion);\r\n            this.historyBoards.push(JSON.parse(JSON.stringify(this.board)));\r\n            this.historyBoards = this.historyBoards.slice(1);\r\n            this.board[destinationRow][destinationCol] = this.board[startRow][startCol]\r\n            if(this.board[startRow][startCol].slice(0,1) === \"k\")\r\n            {\r\n                this.castlePossible[this.current_color] = [false,false];\r\n            }\r\n            else if(this.board[startRow][startCol].slice(0,1) === \"r\")\r\n            {\r\n                this.castlePossible[this.current_color][startCol === 7 ? 1 : 0] = false;\r\n            }\r\n            this.board[startRow][startCol] = EMPTY;\r\n            //Workaround damit man rochieren kann\r\n            if(isCastling)\r\n            {\r\n                this.castlePossible[this.current_color] = [false,false];\r\n                var rookRow = startRow;\r\n                var rookCol = destinationCol === 6 ? 7 : 0;\r\n                var castleCol = rookCol === 7 ? 5 : 3;\r\n                this.board[rookRow][castleCol] = this.board[rookRow][rookCol]\r\n                this.board[rookRow][rookCol] = EMPTY;\r\n            }\r\n            if(isEnPassant)\r\n            {\r\n                var passantRow = startRow;\r\n                var passantCol = destinationCol;\r\n                this.board[passantRow][passantCol] = EMPTY;\r\n            }\r\n            if(isPromotion)\r\n            {\r\n                this.promotePiece(destinationCol, this.current_color, promotionPiece);\r\n            }\r\n            this.calculateChecks();\r\n            this.current_color = this.current_color === WHITE ? BLACK : WHITE;\r\n            if(this.isCheckMate())\r\n            {\r\n                this.checkMate = true;\r\n            }\r\n            var boardsAreEqual = true;\r\n            for(var i = 0; i< 8;i++)\r\n            {\r\n                for(var j = 0;j<8;j++)\r\n                {  \r\n                    if(this.historyBoards[0][j][i] !== this.board[j][i])\r\n                    {\r\n                        boardsAreEqual = false;\r\n                    }\r\n                }\r\n            }\r\n            this.moveRepitition = boardsAreEqual ? this.moveRepitition +1 : 0;\r\n            return [true, isCastling, isEnPassant, isPromotion];\r\n        }\r\n        return [false,false, false, false];\r\n    }\r\n    \r\n    addToMoveHistory(startY, startX, endY, endX, promotionPiece,isPossible, isCastling, isEnPassant, isPromotion)\r\n    {\r\n        if(isPossible)\r\n        {\r\n            if(isCastling)\r\n            {\r\n                if(endX - startX < 0)\r\n                {\r\n                    //Lange Rochade\r\n                    this.moveHistory.push([\r\n                        [startY, startX, endY, endX, this.board[startY][startX], EMPTY], \r\n                        [startY, 0, endY, 3, this.board[startY][0], EMPTY]\r\n                    ]);\r\n                }\r\n                else\r\n                {\r\n                    //Kurze Rochade\r\n                    this.moveHistory.push([\r\n                        [startY, startX, endY, endX,this.board[startY][startX], EMPTY], \r\n                        [startY, 7, endY, 5,this.board[startY][7], EMPTY]\r\n                    ]);\r\n                }\r\n            }\r\n            else if(isEnPassant)\r\n            {\r\n                //En Passant\r\n                this.moveHistory.push([\r\n                    [startY, startX, endY, endX, this.board[startY][startX], this.board[endY][endX]],\r\n                    [startY, endX, startY, endX, EMPTY,this.board[startY][endX]]\r\n                    \r\n                ]);\r\n            }\r\n            else if(isPromotion)\r\n            {\r\n                //Promtion\r\n                this.moveHistory.push([\r\n                    \r\n                    [startY, startX, endY, endX, this.board[startY][startX], this.board[endY][endX]],\r\n                    [endY, endX, endY, endX, promotionPiece+this.current_color, this.board[endY][endX] ]\r\n                ]);\r\n            }\r\n            else{\r\n                this.moveHistory.push([[startY, startX, endY, endX, this.board[startY][startX], this.board[endY][endX]]]);\r\n            }\r\n            this.moveHistoryIndex++;\r\n        }\r\n    }\r\n    \r\n    isInReverse()\r\n    {\r\n        return this.moveHistory.length-1 !== this.moveHistoryIndex;\r\n    }\r\n    \r\n    isValidDestination(row, column)\r\n    {\r\n        return this.board[row][column].slice(1,2) !== this.current_color;\r\n    }\r\n    \r\n    calculateChecks()\r\n    {\r\n        this.isWhiteCheck = this.isCheck(WHITE, this.board);\r\n        this.isBlackCheck = this.isCheck(BLACK, this.board);\r\n    }\r\n    \r\n    simulateMove(startRow,startCol,destinationRow, destinationCol)\r\n    {\r\n        //Überprüft ob man sich selbst Schach setzt durch den Zug, um illegale Züge zu verhindern\r\n        var simBoard = JSON.parse(JSON.stringify(this.board));\r\n        simBoard[destinationRow][destinationCol] = simBoard[startRow][startCol]\r\n        simBoard[startRow][startCol] = EMPTY;\r\n        return !this.isCheck(this.current_color,simBoard);\r\n    }\r\n    \r\n    isMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        //Überprüft ob der Zug nach allen Schachregeln legal ist\r\n        //Returned [Zug möglich, Rochiert?, enPassant?, Promotion?]\r\n        if(startRow < 0 || startRow > 7 || destinationRow < 0 || destinationRow > 7)\r\n        {\r\n            return [false,false,false,false];\r\n        }\r\n        if(startCol < 0 || startCol > 7 || destinationCol < 0 || destinationCol > 7 )\r\n        {\r\n            return [false,false,false,false];\r\n            \r\n        }\r\n        if(destinationRow === startRow && destinationCol === startCol)\r\n        {\r\n            return [false,false,false,false];\r\n            \r\n        }\r\n        switch(this.board[startRow][startCol].slice(0,1))\r\n        {\r\n            case \"p\":\r\n            var [isPossible , isEnPassant, isPromotion] =  this.isPawnMovePossible(startRow,startCol,destinationRow,destinationCol) ;\r\n            return [isPossible && this.simulateMove(startRow,startCol,destinationRow,destinationCol),false, isEnPassant, isPromotion];\r\n            case \"k\":\r\n            var [isPossible, isCastling] = this.isKingMovePossible(startRow,startCol,destinationRow,destinationCol);\r\n            return [isPossible && this.simulateMove(startRow,startCol,destinationRow,destinationCol), isCastling, false, false];\r\n            \r\n            case \"q\":\r\n            return [this.isQueenMovePossible(startRow,startCol,destinationRow,destinationCol) && this.simulateMove(startRow,startCol,destinationRow,destinationCol), false, false, false];\r\n            \r\n            case \"r\":\r\n            return [this.isRookMovePossible(startRow,startCol,destinationRow,destinationCol) && this.simulateMove(startRow,startCol,destinationRow,destinationCol), false, false, false];\r\n            \r\n            case \"n\":\r\n            return [this.isKnightMovePossible(startRow,startCol,destinationRow,destinationCol) && this.simulateMove(startRow,startCol,destinationRow,destinationCol), false, false, false];\r\n            \r\n            case \"b\":\r\n            return [this.isBishopMovePossible(startRow,startCol,destinationRow,destinationCol) && this.simulateMove(startRow,startCol,destinationRow,destinationCol), false, false, false];\r\n            \r\n            default:\r\n            console.log(\"Default Case bei Move Possible\");\r\n            console.log([startRow, startCol, destinationRow, destinationCol]);\r\n            this.printBoard(this.board);\r\n            return [false,false,false,false];\r\n        }\r\n    }\r\n    \r\n    ugly_moves()\r\n    {\r\n        var possibleMoves = [];\r\n        for(var y = 0;y < 8;y++)\r\n        {\r\n            for(var x =0; x<8;x++)\r\n            {\r\n                if(parseInt(this.board[y][x].slice(1,2)) === this.current_color)\r\n                {\r\n                    this.getPossibleMoves(x,y).forEach((move) => (possibleMoves.push([y,x,move[0],move[1], move[2]])));\r\n                }\r\n            }\r\n        }\r\n        return possibleMoves;\r\n    }\r\n    \r\n    ugly_move(move)\r\n    {\r\n        var [startY, startX, endY, endX, promotionPiece] = move;\r\n        this.uglyMoveStates.push([JSON.parse(JSON.stringify(this.historyBoards[0])),JSON.parse(JSON.stringify(this.castlePossible)), this.moveRepitition]);\r\n        \r\n        var initial = this.movePiece(startY,startX,endY,endX, promotionPiece);\r\n        if(!initial[0])\r\n        {\r\n            console.log(move);\r\n            console.log(this.current_color);\r\n            console.log(\"Initial: \" + initial);\r\n            console.log(this.isMovePossible(startY,startX,endY, endX));\r\n            console.log(this.simulateMove(startY,startX,endY, endX));\r\n            this.printBoard(this.board);\r\n            \r\n        }\r\n        if(initial[3])\r\n        {\r\n            this.promotePiece(endX, (1-this.current_color), \"q\");\r\n        }\r\n        this.calculateChecks();\r\n        return initial[0];\r\n    }\r\n    \r\n    goBackInHistory()\r\n    {\r\n        if(this.moveHistoryIndex >= 0)\r\n        {\r\n            for(var i = 0; i<this.moveHistory[this.moveHistoryIndex].length;i++)\r\n            {\r\n                this.revertMove(this.moveHistory[this.moveHistoryIndex][i])\r\n            }\r\n            this.calculateChecks();\r\n            this.moveHistoryIndex--;\r\n        }\r\n    }\r\n    \r\n    goForwardInHistory()\r\n    {\r\n        if(this.moveHistoryIndex < this.moveHistory.length -1)\r\n        {\r\n            for(var i = 0; i<this.moveHistory[this.moveHistoryIndex+1].length;i++)\r\n            {\r\n                this.makeMove(this.moveHistory[this.moveHistoryIndex+1][i])\r\n            }\r\n            this.moveHistoryIndex++;\r\n            this.calculateChecks();\r\n        }\r\n    }\r\n    \r\n    undo()\r\n    {\r\n        //Geht zurück und löscht den letzten Zug\r\n        this.historyBoards.unshift(this.uglyMoveStates[this.uglyMoveStates.length-1][0]);\r\n        this.historyBoards = this.historyBoards.slice(0,this.historyBoards.length-1);\r\n        this.castlePossible = this.uglyMoveStates[this.uglyMoveStates.length-1][1];\r\n        this.current_color = this.current_color === WHITE ? BLACK : WHITE;\r\n        this.checkMate = false;\r\n        this.staleMate = false;\r\n        this.moveRepitition = this.uglyMoveStates[this.uglyMoveStates.length-1][2];\r\n        this.goBackInHistory();\r\n        this.moveHistory = this.moveHistory.slice(0, this.moveHistory.length-1);\r\n        this.uglyMoveStates = this.uglyMoveStates.slice(0, this.uglyMoveStates.length-1);\r\n    }\r\n    \r\n    revertMove(move)\r\n    {\r\n        var [startY, startX , endY, endX, piece, pieceBefore] = move;\r\n        this.board[startY][startX] = piece;\r\n        this.board[endY][endX] = pieceBefore;\r\n    }\r\n    \r\n    makeMove(move)\r\n    {\r\n        var [startY, startX , endY, endX, piece, pieceBefore] = move;\r\n        this.board[startY][startX] = EMPTY;\r\n        this.board[endY][endX] = piece;\r\n    }\r\n    \r\n    \r\n    promotePiece(column, color, promotionPiece)\r\n    {\r\n        if(promotionPiece === \"k\" || promotionPiece === \"p\" )\r\n        {\r\n            return false;\r\n        }\r\n        if(this.board[color*7][column].slice(0,1) === \"p\")\r\n        {\r\n            this.board[color*7][column] = promotionPiece + String(color);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    getKingPosition(color,board)\r\n    {\r\n        var kingX = -1;\r\n        var kingY = -1;\r\n        for(var i = 0; i<64;i++)\r\n        {\r\n            if(board[Math.floor(i/8)][i%8] === \"k\" + String(color))\r\n            {\r\n                kingX = i%8;\r\n                kingY = Math.floor(i/8);\r\n            }\r\n        }\r\n        return [kingX,kingY]\r\n    }\r\n    \r\n    isCheck(color, board)\r\n    {\r\n        /*\r\n        Überprüft ob der König der jeweiligen Schach gesetzt ist, indem man den König zu einer Art Gottfigur macht und schaut, ob er eine gegnerische Figur\r\n        schlagen mit den eigenen Waffen schlagen könnte.\r\n        Bspw:\r\n        Ob eine Dame in der gleichen Diagonale oder Reihe ist\r\n        Ob ein Turm in der gleichen Reihe oder Spalte ist\r\n        Ob ein Bauer ein Feld von ihm in der Diagonale ist\r\n        Ob ein Läufer in einer ununterbrochenen Diagonale ist\r\n        Ob ein Springer ihn schlagen könnte\r\n        */\r\n        var kingX = -1;\r\n        var kingY = -1;\r\n        //Findet den König der Farbe\r\n        [kingX,kingY] = this.getKingPosition(color,board);\r\n        if(kingX === -1 || kingY === -1)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        var otherKingX = this.getKingPosition(1-color,board)[0];\r\n        var otherKingY = this.getKingPosition(1-color,board)[1];\r\n\r\n        if(Math.abs(kingX-otherKingX) <= 1 && Math.abs(kingY-otherKingY) <= 1)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        //Zeile und Spalte checken\r\n        //Zeile\r\n        var row = board[kingY];\r\n\r\n        //Rechtsseitig vom König in der Zeile\r\n        for(var i = kingX+1; i<8;i++)\r\n        {\r\n            if(parseInt(row[i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(row[i].slice(0,1) === \"q\" || row[i].slice(0,1) === \"r\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(row[i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n        }\r\n        //Linksseitig vom König in der Zeile\r\n        for(i = kingX-1; i>=0;i--)\r\n        {\r\n            if(parseInt(row[i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(row[i].slice(0,1) === \"q\" || row[i].slice(0,1) === \"r\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(row[i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n        }\r\n        \r\n        //Spalte\r\n        //Unterhalb vom König in der Spalte\r\n        var column = this.arrayColumn(board,kingX)\r\n        for(i = kingY+1; i<8;i++)\r\n        {\r\n            if(parseInt(column[i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(column[i].slice(0,1) === \"q\" || column[i].slice(0,1) === \"r\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(column[i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n        }\r\n        //Oberhalb vom König in der Spalte\r\n        for( i = kingY-1; i>=0;i--)\r\n        {\r\n            if(parseInt(column[i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(column[i].slice(0,1) === \"q\" || column[i].slice(0,1) === \"r\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(column[i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n        }\r\n        \r\n        //Diagonale checken + Bauern checken\r\n        var diagonals = this.getDiagonals(kingX,kingY, board);\r\n        //Von Links oben nach Rechts unten Diagonale\r\n        //Unterhalb des Köngis\r\n        var counter = 1;\r\n        for(i = Math.min(kingX,kingY)+1; i < diagonals[0].length;i++)\r\n        {\r\n            if(parseInt(diagonals[0][i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(diagonals[0][i].slice(0,1) === \"q\" || diagonals[0][i].slice(0,1) === \"b\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[0][i] === \"p0\" && counter === 1 && color === BLACK)\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[0][i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n            counter++;\r\n        }\r\n        //Oberhalb des Köngis\r\n        counter = 1;\r\n        for( i = Math.min(kingX,kingY)-1; i >= 0;i--)\r\n        {\r\n            if(parseInt(diagonals[0][i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(diagonals[0][i].slice(0,1) === \"q\" || diagonals[0][i].slice(0,1) === \"b\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[0][i] === \"p1\" && counter === 1  && color === WHITE)\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[0][i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n            counter++;\r\n        }\r\n        //Von Rechts oben nach Links unten Diagonale\r\n        //Unterhalb des Königs\r\n        counter = 1;\r\n        \r\n        for( i = Math.min(7-kingX,kingY)+1; i < diagonals[1].length;i++)\r\n        {\r\n            if(parseInt(diagonals[1][i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(diagonals[1][i].slice(0,1) === \"q\" || diagonals[1][i].slice(0,1) === \"b\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[1][i] === \"p0\" && counter === 1 && color === BLACK)\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[1][i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            counter++;\r\n        }\r\n        //Oberhalb des Köngis\r\n        counter = 1;\r\n        for(i = Math.min(7-kingX,kingY)-1; i >= 0;i--)\r\n        {\r\n            if(parseInt(diagonals[1][i].slice(1,2)) === color)\r\n            {\r\n                break;\r\n            }\r\n            else if(diagonals[1][i].slice(0,1) === \"q\" || diagonals[1][i].slice(0,1) === \"b\")\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[1][i] === \"p1\" && counter === 1  && color === WHITE)\r\n            {\r\n                return true;\r\n            }\r\n            else if(diagonals[1][i] !== EMPTY)\r\n            {\r\n                break;\r\n            }\r\n            \r\n            counter++;\r\n        }\r\n        \r\n        //Springer checken\r\n        var knightMoves = this.getInboundKnightMoves(kingX,kingY);\r\n        for( i = 0; i<knightMoves.length;i++)\r\n        {\r\n            var jumpX = knightMoves[i][0] + kingX;\r\n            var jumpY = knightMoves[i][1] + kingY;\r\n            \r\n            if(board[jumpY][jumpX].slice(0,1) === \"n\" && parseInt(board[jumpY][jumpX].slice(1,2)) !== color)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    \r\n    isCheckMate()\r\n    {\r\n        //Überprüft, ob die aktuelle Farbe Matt gesetzt ist\r\n        if(this.moveRepitition >= 6)\r\n        {\r\n            this.staleMate = true;\r\n            return false;\r\n        }\r\n        for(var i =0; i<8;i++)\r\n        {\r\n            for(var j =0;j<8;j++)\r\n            {\r\n                if(parseInt(this.board[i][j].slice(1,2)) === this.current_color)\r\n                {\r\n                    if(this.getPossibleMoves(j,i).length !== 0)\r\n                    {\r\n                        return false;\r\n                    }\r\n                }           \r\n            }\r\n            \r\n            \r\n        }\r\n        \r\n        if(!this.isCheck(this.current_color,this.board))\r\n        {\r\n            this.staleMate = true;\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    getInboundKnightMoves(x,y)\r\n    {\r\n        var knightPattern = [[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1]];\r\n        var possibleMoves = [];\r\n        for(var i=0;i<knightPattern.length;i++)\r\n        {\r\n            if(x+knightPattern[i][0] < 8 && x+knightPattern[i][0] >= 0 && y+knightPattern[i][1] < 8  && y+knightPattern[i][1] >= 0)\r\n            {\r\n                possibleMoves.push(knightPattern[i]);\r\n            }\r\n        }\r\n        return possibleMoves;\r\n    }\r\n    \r\n    getDiagonals(x,y, board)\r\n    {\r\n        var diagonals = [];\r\n        //Von Links oben nach Rechts unten Diagonale\r\n        var curX = x -  Math.min(x,y);\r\n        var curY = y -  Math.min(x,y);\r\n        var firstDiagonal = [];\r\n        while(curX < 8 && curY < 8)\r\n        {\r\n            firstDiagonal.push(board[curY][curX])\r\n            curY++;\r\n            curX++;\r\n        }\r\n        diagonals.push(firstDiagonal);\r\n        //Rechts oben nach Links unten\r\n        curX = x +  Math.min(7-x,y);\r\n        curY = y -  Math.min(7-x,y);\r\n        var secondDiagonal = [];\r\n        while(curX >= 0 && curY < 8)\r\n        {\r\n            secondDiagonal.push(board[curY][curX])\r\n            curY++;\r\n            curX--;\r\n        }\r\n        diagonals.push(secondDiagonal);\r\n        return diagonals;\r\n        \r\n    }\r\n    \r\n    isPawnMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        /*\r\n        Es gibt 4 Fälle für den Bauern:\r\n        1 oder 2 nach Vorne\r\n        Schlagen\r\n        En passant\r\n        */\r\n        //Bauer läuft nach vorne\r\n        // colorShift ist dafür da um eine Reihe weiter zu gehen aus Sicht der jeweiligen Farbe also für weiß(=0) -1 und schwarz(1) +1\r\n        var colorShiftRow = (-1)**(this.current_color+1)\r\n        var promotion = false;\r\n        var enPassant = false;\r\n        //Überprüft ob der ausgewählte Bauer die zu spielende Farbe hat und in die richtige Richtung will\r\n        if(parseInt(this.board[startRow][startCol].slice(1,2)) !== this.current_color || Math.abs(destinationRow-startRow) !== (destinationRow-startRow)*colorShiftRow )\r\n        {\r\n            return [false,false,false];\r\n            \r\n        }\r\n        if(startCol === destinationCol)\r\n        {\r\n            var distanceForward = -1*colorShiftRow*(startRow-destinationRow);\r\n            //Läuft ein Feld\r\n            if(this.board[destinationRow][destinationCol] === EMPTY && distanceForward === 1)\r\n            {\r\n                if(destinationRow === this.current_color * 7)\r\n                {\r\n                    promotion = true;\r\n                }\r\n                return [true, enPassant, promotion];\r\n            }\r\n            //Läuft 2 Felder\r\n            if(startRow === 6-this.current_color*5 && distanceForward === 2)\r\n            {\r\n                if(this.board[destinationRow][destinationCol] === EMPTY && this.board[destinationRow-colorShiftRow][destinationCol] === EMPTY)\r\n                {\r\n                    \r\n                    return [true, enPassant, promotion];\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //Bauer schlägt und soll maximal 1 Feld laufen können\r\n            if(Math.abs(startRow-destinationRow) === 1 && Math.abs(startCol-destinationCol) === 1)\r\n            {\r\n                if(parseInt(this.board[destinationRow][destinationCol].slice(1,2)) !== this.current_color && this.board[destinationRow][destinationCol] !== EMPTY )\r\n                {\r\n                    if(destinationRow === this.current_color * 7)\r\n                    {\r\n                        promotion = true;\r\n                    }\r\n                    return [true, enPassant, promotion];\r\n                    \r\n                    \r\n                }\r\n                //Überprüft en passant\r\n                //Ist das Zielfeld leer und es entweder Reihe 2 oder 6\r\n                if(this.board[destinationRow][destinationCol] === EMPTY && destinationRow === 5-(1-this.current_color)*3)\r\n                {\r\n                    //Ist ein En Passant Bauer direkt neben dem Bauern\r\n                    if(this.board[destinationRow+colorShiftRow][destinationCol] === EMPTY && this.board[startRow][destinationCol] === \"p\" + String(1-this.current_color))\r\n                    {\r\n                        //Ist der Bauer neben einem im letzten Zug gesprungen\r\n                        if(this.historyBoards[3][destinationRow+colorShiftRow][destinationCol] === \"p\" + String(1-this.current_color))\r\n                        {\r\n                            enPassant = true;\r\n                            return [true, enPassant, promotion];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [false,false,false];\r\n    }\r\n    \r\n    isKingMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        if(parseInt(this.board[destinationRow][destinationCol].slice(1,2)) === this.current_color)\r\n        {\r\n            return [false, false];\r\n            \r\n        }\r\n        //Entweder er läuft 1 Feld oder rochiert\r\n        var rowDifference = Math.abs(destinationRow-startRow);\r\n        var colDifference = Math.abs(destinationCol-startCol);\r\n        if(rowDifference > 1)\r\n        {\r\n            return [false, false];\r\n            \r\n        }        \r\n        \r\n        if(colDifference <= 1)\r\n        {\r\n            if(this.board[destinationRow][destinationCol] === EMPTY || parseInt(this.board[destinationRow][destinationCol].slice(1,2)) !== this.current_color )\r\n            {\r\n                \r\n                return [true, false];\r\n            }\r\n        }\r\n        //Lange oder kurze Rochade überprüfen\r\n        var shortCastle = (colDifference === destinationCol-startCol);\r\n        if(this.castlePossible[this.current_color][shortCastle ? 1 : 0])\r\n        {\r\n            if(shortCastle)\r\n            {\r\n                //Kurze Rochade\r\n                if(this.isCheck(this.current_color, this.board))\r\n                {\r\n                    return [false,false];\r\n                }       \r\n                for(var i = 1;i<3;i++)\r\n                {\r\n                    if(this.board[destinationRow][startCol+i] !== EMPTY || !this.simulateMove(startRow,startCol,destinationRow,startCol+i))\r\n                    {\r\n                        return [false, false];\r\n                    }\r\n                }\r\n                if(this.board[destinationRow][7] !== \"r\"  + this.current_color.toString())\r\n                {\r\n                    return [false,false];\r\n                }\r\n                return [true, true];\r\n            }\r\n            //Lange Rochade\r\n            if(this.isCheck(this.current_color, this.board))\r\n            {\r\n                return [false,false];\r\n            } \r\n            for( i = 1;i<4;i++)\r\n            {\r\n                if(i< 3)\r\n                {\r\n                    if(this.board[destinationRow][startCol-i] !== EMPTY || !this.simulateMove(startRow,startCol,destinationRow,startCol-i))\r\n                    {\r\n                        return [false, false];\r\n                        \r\n                    }\r\n                }\r\n                else if(this.board[destinationRow][startCol-i] !== EMPTY)\r\n                {\r\n                    return [false,false];\r\n                }\r\n                \r\n            }\r\n            if(this.board[destinationRow][0] !== \"r\" + this.current_color.toString())\r\n            {\r\n                return [false,false];\r\n            }\r\n            return [true, true];\r\n            \r\n        }\r\n        \r\n        return [false, false];\r\n        \r\n        \r\n    }\r\n    \r\n    isQueenMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        if(startRow === destinationRow || startCol === destinationCol)\r\n        {\r\n            return this.isRookMovePossible(startRow, startCol, destinationRow, destinationCol);\r\n        }\r\n        else\r\n        {\r\n            return this.isBishopMovePossible(startRow, startCol, destinationRow, destinationCol);\r\n        }\r\n    }\r\n    \r\n    isRookMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        if(parseInt(this.board[destinationRow][destinationCol].slice(1,2)) === this.current_color)\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        if(startRow === destinationRow)\r\n        {\r\n            var row = this.board[startRow];\r\n            var startX = Math.min(startCol,destinationCol);\r\n            var endX = Math.max(startCol,destinationCol);\r\n            for(var i = startX+1; i < endX; i++)\r\n            {\r\n                if(row[i] !== EMPTY)\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if(startCol === destinationCol)\r\n        {\r\n            var column = this.arrayColumn(this.board, startCol);\r\n            var startY = Math.min(startRow,destinationRow);\r\n            var endY = Math.max(startRow,destinationRow);\r\n            for( i = startY+1; i < endY; i++)\r\n            {\r\n                if(column[i] !== EMPTY)\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    isBishopMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        if(Math.abs(startRow-destinationRow) !== Math.abs(startCol-destinationCol))\r\n        {\r\n            return false;\r\n        }\r\n        if(parseInt(this.board[destinationRow][destinationCol].slice(1,2)) === this.current_color)\r\n        {\r\n            return false;\r\n        }\r\n        //Überprüft ob der obere Punkt weiter links ist als der unterste Punkt und damit ob die Diagonale von links nach rechts verläuft\r\n        if([startCol,destinationCol][[destinationRow,startRow].indexOf(Math.min.apply(Math, [startRow,destinationRow]))] === Math.max(startCol,destinationCol) )\r\n        {\r\n            //Von Links oben nach Rechts unten\r\n            var startX = Math.min(startCol,destinationCol);\r\n            var startY = Math.min(startRow,destinationRow);\r\n            var distance = Math.abs(startRow-destinationRow);\r\n            for(var i = 1; i<distance;i++)\r\n            {\r\n                if(this.board[startY+i][startX+i] !== EMPTY)\r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //Von Rechts oben nach Links unten\r\n            startX = Math.min(7-startCol,7-destinationCol);\r\n            startY = Math.min(startRow,destinationRow);\r\n            distance = Math.abs(startRow-destinationRow);\r\n            for( i = 1; i < distance ;i++)\r\n            {\r\n                if(this.board[startY+i][7-startX-i] !== EMPTY)\r\n                {\r\n                    \r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n    \r\n    isKnightMovePossible(startRow, startCol, destinationRow, destinationCol)\r\n    {\r\n        var knightMoves = this.getInboundKnightMoves(startRow,startCol);\r\n        var rowDifference = destinationRow-startRow;\r\n        var colDifference = destinationCol-startCol;\r\n        for(var i = 0; i<knightMoves.length;i++)\r\n        {   \r\n            if(rowDifference === knightMoves[i][0] && colDifference === knightMoves[i][1])\r\n            {\r\n                if(parseInt(this.board[destinationRow][destinationCol].slice(1,2)) !== this.current_color)\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    getPossibleMoves(startX, startY)\r\n    {\r\n        var colorShift = (-1)**(this.current_color+1)\r\n        var piece = this.board[startY][startX].slice(0,1);\r\n        var possibleMoves = []\r\n        \r\n        switch(piece)\r\n        {\r\n            case \"p\":\r\n            var moves = [[colorShift,0],[colorShift*2,0],[colorShift,-1],[colorShift,1]]\r\n            for(var k = 0; k<moves.length; k++)\r\n            {\r\n                if(this.isMovePossible(startY,startX,startY+moves[k][0],startX+moves[k][1])[0])\r\n                {\r\n                    if(startY+moves[k][0] == 7 ||startY+moves[k][0] == 0 )\r\n                    {\r\n                        possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"q\"+this.current_color]);\r\n                        possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"r\"+this.current_color]);\r\n                        possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"n\" + this.current_color]);\r\n                        possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"b\" + this.current_color]);\r\n                    }\r\n                    else{\r\n                        possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"-\"]);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n            case \"k\":\r\n            moves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 0], [0, 1], [1, -1], [1, 0], [1, 1],[0,-2],[0,2]]\r\n            for( k = 0; k<moves.length; k++)\r\n            {\r\n                if(this.isMovePossible(startY,startX,startY+moves[k][0],startX+moves[k][1])[0])\r\n                {\r\n                    possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"-\"]);\r\n                }\r\n            }\r\n            break;\r\n            case \"q\":\r\n            var rookMoves = this.getRookMoves(startX,startY);\r\n            var bishopMoves = this.getBishopMoves(startX,startY);\r\n            \r\n            for(var i = 0;i<rookMoves.length;i++)\r\n            {\r\n                possibleMoves.push([rookMoves[i][0],rookMoves[i][1], rookMoves[i][2], rookMoves[i][3], \"-\"]);\r\n            }\r\n            for(i = 0;i<bishopMoves.length;i++)\r\n            {\r\n                possibleMoves.push([bishopMoves[i][0],bishopMoves[i][1],bishopMoves[i][2],bishopMoves[i][3],\"-\"]);\r\n            }\r\n            \r\n            break;\r\n            case \"r\":\r\n            possibleMoves = this.getRookMoves(startX,startY).map(rookMove => [rookMove[0],rookMove[1], rookMove[2], rookMove[3], \"-\"]);\r\n            break;\r\n            case \"n\":\r\n            moves = this.getInboundKnightMoves(startY,startX);\r\n            for( k = 0; k<moves.length ; k++)\r\n            {\r\n                if(this.isMovePossible(startY,startX,startY+moves[k][0],startX+moves[k][1])[0])\r\n                {\r\n                    possibleMoves.push([startY+moves[k][0],startX+moves[k][1], \"-\"]);\r\n                }\r\n            }\r\n            break;\r\n            case \"b\":\r\n            possibleMoves = this.getBishopMoves(startX,startY).map(bishopMove => [bishopMove[0],bishopMove[1],bishopMove[2],bishopMove[3],\"-\"]);\r\n            break;\r\n            default:\r\n            console.log(\"Fehler bei Switch für getMoves\");\r\n            return null;\r\n        }\r\n        return possibleMoves;\r\n    }\r\n    \r\n    getRookMoves(startX,startY)\r\n    {\r\n        var possibleMoves = [];\r\n        for(var k = 1; k<8;k++)\r\n        {\r\n            if(this.isMovePossible(startY,startX,startY+k,startX)[0])\r\n            {\r\n                possibleMoves.push([startY+k,startX]);\r\n            }\r\n            if(this.isMovePossible(startY,startX,startY-k,startX)[0])\r\n            {\r\n                possibleMoves.push([startY-k,startX]);\r\n            }\r\n            if(this.isMovePossible(startY,startX,startY,startX+k)[0])\r\n            {\r\n                possibleMoves.push([startY,startX+k]);\r\n            }\r\n            if(this.isMovePossible(startY,startX,startY,startX-k)[0])\r\n            {\r\n                possibleMoves.push([startY,startX-k]);\r\n            }\r\n        }\r\n        return possibleMoves;\r\n    }\r\n    \r\n    getBishopMoves(startX,startY)\r\n    {\r\n        var possibleMoves = []\r\n        for(var k = 1; k<8;k++)\r\n        {\r\n            if(this.isMovePossible(startY,startX,startY+k,startX+k)[0])\r\n            {\r\n                possibleMoves.push([startY+k,startX+k]);\r\n            }\r\n            if(this.isMovePossible(startY,startX,startY+k,startX-k)[0])\r\n            {\r\n                possibleMoves.push([startY+k,startX-k]);\r\n            }\r\n            if(this.isMovePossible(startY,startX,startY-k,startX+k)[0])\r\n            {\r\n                possibleMoves.push([startY-k,startX+k]);\r\n            }\r\n            if(this.isMovePossible(startY,startX,startY-k,startX-k)[0])\r\n            {\r\n                possibleMoves.push([startY-k,startX-k]);\r\n            }\r\n        }\r\n        return possibleMoves;\r\n    }\r\n    \r\n}",["47","48"],"C:\\Users\\chrfe\\Desktop\\Informatik Projekte\\Website\\react\\chess-game\\src\\chess_ai.js",["49","50","51"],"let EMPTY = \"  \";\r\nvar minimaxRoot =function(depth, game, isMaximisingPlayer) {\r\n    \r\n    var newGameMoves = game.ugly_moves();\r\n    var bestMove = -9999;\r\n    var bestMoveFound;\r\n    \r\n    \r\n    for(var i = 0; i < newGameMoves.length; i++) {\r\n        var newGameMove = newGameMoves[i]\r\n        var moveWasPlayed = game.ugly_move(newGameMove);\r\n        var value = minimax(depth - 1, game, -10000, 10000, !isMaximisingPlayer);\r\n        if(moveWasPlayed)\r\n        {\r\n            game.undo();\r\n        }\r\n        else{\r\n            game.printStatus(newGameMove);\r\n        }\r\n        if(value >= bestMove) {\r\n            bestMove = value;\r\n            bestMoveFound = newGameMove;\r\n        }\r\n    }\r\n    return bestMoveFound;\r\n};\r\n\r\nexport default minimaxRoot;\r\n\r\nvar minimax = function (depth, game, alpha, beta, isMaximisingPlayer) {\r\n    if (depth === 0) {\r\n        return -evaluateBoard(game.board);\r\n    }\r\n    \r\n    var newGameMoves = game.ugly_moves();\r\n    \r\n    if (isMaximisingPlayer) {\r\n        var bestMove = -9999;\r\n        for (var i = 0; i < newGameMoves.length; i++) {\r\n            var moveWasPlayed = game.ugly_move(newGameMoves[i]);\r\n            bestMove = Math.max(bestMove, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));\r\n            if(moveWasPlayed)\r\n            {\r\n                game.undo();\r\n            }\r\n            else{\r\n                game.printStatus(newGameMoves[i]);\r\n            }\r\n            alpha = Math.max(alpha, bestMove);\r\n            if (beta <= alpha) {\r\n                return bestMove;\r\n            }\r\n        }\r\n        return bestMove;\r\n    } else {\r\n        var bestMove = 9999;\r\n        for (var i = 0; i < newGameMoves.length; i++) {\r\n            moveWasPlayed = game.ugly_move(newGameMoves[i]);\r\n            bestMove = Math.min(bestMove, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));\r\n            if(moveWasPlayed)\r\n            {\r\n                game.undo();\r\n            }\r\n            else{\r\n                game.printStatus(newGameMoves[i]);\r\n            }\r\n            beta = Math.min(beta, bestMove);\r\n            if (beta <= alpha) {\r\n                return bestMove;\r\n            }\r\n        }\r\n        return bestMove;\r\n    }\r\n};\r\n\r\nvar evaluateBoard = function (board) {\r\n    var totalEvaluation = 0;\r\n    for (var i = 0; i < 8; i++) {\r\n        for (var j = 0; j < 8; j++) {\r\n            totalEvaluation = totalEvaluation + getPieceValue(board[i][j], i ,j);\r\n        }\r\n    }\r\n    return totalEvaluation;\r\n};\r\n\r\nvar reverseArray = function(array) {\r\n    return array.slice().reverse();\r\n};\r\n\r\nvar pawnEvalWhite =\r\n[\r\n    [0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0],\r\n    [5.0,  5.0,  5.0,  5.0,  5.0,  5.0,  5.0,  5.0],\r\n    [1.0,  1.0,  2.0,  3.0,  3.0,  2.0,  1.0,  1.0],\r\n    [0.5,  0.5,  1.0,  2.5,  2.5,  1.0,  0.5,  0.5],\r\n    [0.0,  0.0,  0.0,  2.0,  2.0,  0.0,  0.0,  0.0],\r\n    [0.5, -0.5, -1.0,  0.0,  0.0, -1.0, -0.5,  0.5],\r\n    [0.5,  1.0, 1.0,  -2.0, -2.0,  1.0,  1.0,  0.5],\r\n    [0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0]\r\n];\r\n\r\nvar pawnEvalBlack = reverseArray(pawnEvalWhite);\r\n\r\nvar knightEval =\r\n[\r\n    [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0],\r\n    [-4.0, -2.0,  0.0,  0.0,  0.0,  0.0, -2.0, -4.0],\r\n    [-3.0,  0.0,  1.0,  1.5,  1.5,  1.0,  0.0, -3.0],\r\n    [-3.0,  0.5,  1.5,  2.0,  2.0,  1.5,  0.5, -3.0],\r\n    [-3.0,  0.0,  1.5,  2.0,  2.0,  1.5,  0.0, -3.0],\r\n    [-3.0,  0.5,  1.0,  1.5,  1.5,  1.0,  0.5, -3.0],\r\n    [-4.0, -2.0,  0.0,  0.5,  0.5,  0.0, -2.0, -4.0],\r\n    [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0]\r\n];\r\n\r\nvar bishopEvalWhite = [\r\n    [ -2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0],\r\n    [ -1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -1.0],\r\n    [ -1.0,  0.0,  0.5,  1.0,  1.0,  0.5,  0.0, -1.0],\r\n    [ -1.0,  0.5,  0.5,  1.0,  1.0,  0.5,  0.5, -1.0],\r\n    [ -1.0,  0.0,  1.0,  1.0,  1.0,  1.0,  0.0, -1.0],\r\n    [ -1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0, -1.0],\r\n    [ -1.0,  0.5,  0.0,  0.0,  0.0,  0.0,  0.5, -1.0],\r\n    [ -2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0]\r\n];\r\n\r\nvar bishopEvalBlack = reverseArray(bishopEvalWhite);\r\n\r\nvar rookEvalWhite = [\r\n    [  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0],\r\n    [  0.5,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  0.5],\r\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\r\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\r\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\r\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\r\n    [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],\r\n    [  0.0,   0.0, 0.0,  0.5,  0.5,  0.0,  0.0,  0.0]\r\n];\r\n\r\nvar rookEvalBlack = reverseArray(rookEvalWhite);\r\n\r\nvar evalQueen = [\r\n    [ -2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0],\r\n    [ -1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -1.0],\r\n    [ -1.0,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -1.0],\r\n    [ -0.5,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -0.5],\r\n    [  0.0,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -0.5],\r\n    [ -1.0,  0.5,  0.5,  0.5,  0.5,  0.5,  0.0, -1.0],\r\n    [ -1.0,  0.0,  0.5,  0.0,  0.0,  0.0,  0.0, -1.0],\r\n    [ -2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0]\r\n];\r\n\r\nvar kingEvalWhite = [\r\n    \r\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\r\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\r\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\r\n    [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],\r\n    [ -2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0],\r\n    [ -1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0],\r\n    [  2.0,  2.0,  0.0,  0.0,  0.0,  0.0,  2.0,  2.0 ],\r\n    [  2.0,  3.0,  1.0,  0.0,  0.0,  1.0,  3.0,  2.0 ]\r\n];\r\n\r\nvar kingEvalBlack = reverseArray(kingEvalWhite);\r\n\r\n\r\n\r\n\r\nvar getPieceValue = function (piece, y, x) {\r\n    if (piece === EMPTY) {\r\n        return 0;\r\n    }\r\n    var getAbsoluteValue = function (piece, isWhite, x ,y) {\r\n        if (piece.slice(0,1) === 'p') {\r\n            return 10 + ( isWhite ? pawnEvalWhite[y][x] : pawnEvalBlack[y][x] );\r\n        } else if (piece.slice(0,1)  === 'r') {\r\n            return 50 + ( isWhite ? rookEvalWhite[y][x] : rookEvalBlack[y][x] );\r\n        } else if (piece.slice(0,1)  === 'n') {\r\n            return 30 + knightEval[y][x];\r\n        } else if (piece.slice(0,1)  === 'b') {\r\n            return 30 + ( isWhite ? bishopEvalWhite[y][x] : bishopEvalBlack[y][x] );\r\n        } else if (piece.slice(0,1)  === 'q') {\r\n            return 90 + evalQueen[y][x];\r\n        } else if (piece.slice(0,1)  === 'k') {\r\n            return 900 + ( isWhite ? kingEvalWhite[y][x] : kingEvalBlack[y][x] );\r\n        }\r\n        throw \"Unknown piece type: \" + piece.slice(0,1) ;\r\n    };\r\n    \r\n    var absoluteValue = getAbsoluteValue(piece, parseInt(piece.slice(1,2)) === 0, x ,y);\r\n    return parseInt(piece.slice(1,2)) === 0 ? absoluteValue : -absoluteValue;\r\n};",{"ruleId":"52","severity":1,"message":"53","line":3,"column":18,"nodeType":"54","messageId":"55","endLine":3,"endColumn":24},{"ruleId":"52","severity":1,"message":"56","line":8,"column":5,"nodeType":"54","messageId":"55","endLine":8,"endColumn":10},{"ruleId":"52","severity":1,"message":"57","line":10,"column":5,"nodeType":"54","messageId":"55","endLine":10,"endColumn":10},{"ruleId":"58","severity":1,"message":"59","line":88,"column":39,"nodeType":"60","messageId":"61","endLine":88,"endColumn":41},{"ruleId":"52","severity":1,"message":"62","line":111,"column":16,"nodeType":"54","messageId":"55","endLine":111,"endColumn":26},{"ruleId":"52","severity":1,"message":"63","line":111,"column":28,"nodeType":"54","messageId":"55","endLine":111,"endColumn":38},{"ruleId":"52","severity":1,"message":"64","line":111,"column":40,"nodeType":"54","messageId":"55","endLine":111,"endColumn":51},{"ruleId":"65","severity":1,"message":"66","line":115,"column":13,"nodeType":"67","endLine":115,"endColumn":45},{"ruleId":"65","severity":1,"message":"66","line":131,"column":13,"nodeType":"67","endLine":131,"endColumn":45},{"ruleId":"65","severity":1,"message":"66","line":133,"column":11,"nodeType":"67","endLine":133,"endColumn":34},{"ruleId":"65","severity":1,"message":"66","line":134,"column":11,"nodeType":"67","endLine":134,"endColumn":43},{"ruleId":"65","severity":1,"message":"66","line":138,"column":11,"nodeType":"67","endLine":138,"endColumn":34},{"ruleId":"65","severity":1,"message":"66","line":142,"column":13,"nodeType":"67","endLine":142,"endColumn":45},{"ruleId":"65","severity":1,"message":"66","line":149,"column":13,"nodeType":"67","endLine":149,"endColumn":45},{"ruleId":"65","severity":1,"message":"66","line":151,"column":11,"nodeType":"67","endLine":151,"endColumn":34},{"ruleId":"65","severity":1,"message":"66","line":152,"column":11,"nodeType":"67","endLine":152,"endColumn":43},{"ruleId":"65","severity":1,"message":"66","line":167,"column":11,"nodeType":"67","endLine":167,"endColumn":34},{"ruleId":"65","severity":1,"message":"66","line":171,"column":13,"nodeType":"67","endLine":171,"endColumn":45},{"ruleId":"52","severity":1,"message":"68","line":1,"column":8,"nodeType":"54","messageId":"55","endLine":1,"endColumn":17},{"ruleId":"58","severity":1,"message":"59","line":78,"column":18,"nodeType":"60","messageId":"61","endLine":78,"endColumn":20},{"ruleId":"58","severity":1,"message":"69","line":99,"column":22,"nodeType":"60","messageId":"61","endLine":99,"endColumn":24},{"ruleId":"70","severity":1,"message":"71","line":129,"column":21,"nodeType":"54","messageId":"72","endLine":129,"endColumn":22},{"ruleId":"70","severity":1,"message":"73","line":131,"column":25,"nodeType":"54","messageId":"72","endLine":131,"endColumn":26},{"ruleId":"58","severity":1,"message":"59","line":151,"column":18,"nodeType":"60","messageId":"61","endLine":151,"endColumn":20},{"ruleId":"58","severity":1,"message":"69","line":162,"column":22,"nodeType":"60","messageId":"61","endLine":162,"endColumn":24},{"ruleId":"70","severity":1,"message":"74","line":381,"column":18,"nodeType":"54","messageId":"72","endLine":381,"endColumn":28},{"ruleId":"75","severity":1,"message":"76","line":413,"column":56,"nodeType":"77","messageId":"78","endLine":413,"endColumn":118},{"ruleId":"52","severity":1,"message":"79","line":494,"column":50,"nodeType":"54","messageId":"55","endLine":494,"endColumn":61},{"ruleId":"58","severity":1,"message":"59","line":1113,"column":43,"nodeType":"60","messageId":"61","endLine":1113,"endColumn":45},{"ruleId":"58","severity":1,"message":"59","line":1113,"column":69,"nodeType":"60","messageId":"61","endLine":1113,"endColumn":71},{"ruleId":"80","replacedBy":"81"},{"ruleId":"82","replacedBy":"83"},{"ruleId":"70","severity":1,"message":"84","line":56,"column":13,"nodeType":"54","messageId":"72","endLine":56,"endColumn":21},{"ruleId":"70","severity":1,"message":"71","line":57,"column":18,"nodeType":"54","messageId":"72","endLine":57,"endColumn":19},{"ruleId":"85","severity":1,"message":"86","line":188,"column":9,"nodeType":"87","messageId":"88","endLine":188,"endColumn":58},"no-unused-vars","'Switch' is defined but never used.","Identifier","unusedVar","'WHITE' is assigned a value but never used.","'EMPTY' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'isPossible' is assigned a value but never used.","'isCastling' is assigned a value but never used.","'isEnPassant' is assigned a value but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'testUtils' is defined but never used.","Expected '!==' and instead saw '!='.","no-redeclare","'i' is already defined.","redeclared","'j' is already defined.","'isPossible' is already defined.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'y', 'x'.","ArrowFunctionExpression","unsafeRefs","'pieceBefore' is assigned a value but never used.","no-native-reassign",["89"],"no-negated-in-lhs",["90"],"'bestMove' is already defined.","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-global-assign","no-unsafe-negation"]